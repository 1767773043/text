# 编码规则
s = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
# 字母出现频率
frequency = [0.082,0.015,0.028,0.043,0.127,0.022,0.02,0.061,0.07,0.002,0.008,0.04,0.024,0.06,0.075,0.019,0.001,0.06,0.063,0.091,0.028,0.01,0.023,0.001,0.02,0.001]

# 重合指数: 任意两个位置上，字母相同的概率之和
# 随机产生的英文序列，CI约为0.0385
# 正常出现的英文序列，CI约为0.0687

# 将密文划分为l个子串，子串存放在字典d中。分别计算l个子串的重合指数，然后计算l个重合指数的平均数，
# 如果该平均数位于[0.06,0.07]这个区间内，则说明密钥长度为l，返回密钥长度以及划分的l个子串；
# 如果得到的平均数不在[0.06,0.07]这个区间内，则l自增，d初始化，进行下一轮猜解。

def guess_len_key(crypt):
    """
    guess_len_key函数的主要作用是通过密文猜解密钥长度
    :param crypt: 密文
    :return: 密钥长度以及划为的子串
    """
    l = 2   # 可能的秘钥长度
    d = {}  # 依据秘钥长度划分的子串
    while True:
        print("****************************假设密钥长度为%s***********************************" % l)
        sum_index = 0.0
        for i in range(len(crypt)):
            n = i % l   # n为划分的子串个数
            if n not in d: # 初始化d这个字典，key为0~(n-1)，value为空
                d[n] = ''
            d[n] += crypt[i]
        # 求这个子串的重合指数
        sum_index = sum(coincidence_index(d[j]) for j in range(l)) / l
        if sum_index >= 0.06 and sum_index <= 0.07:
            break
        else:
            l += 1
            d = {}
    return l,d


# 确定密钥长度大致过程是：利用之前得到的l个子串，对每个子串都进行移位操作。
# 假设现在对第i个子串进行移位操作（子串的每个字符移动相同的位数，最坏情况下对同一个子串需要进行26次移位操作），
# 移动的位数为k,（k在[0-25]区间内，也就对应了[a-z]）。
# 每进行一次移位操作，就对该子串计算一次拟重合指数，如果该拟重合指数位于[0.06,0.07]这个区间内，
# 则说明此时移动的位数对应的s列表中的字符即为该子串的密钥；否则，继续进行下一次移位操作。

def crack_key():
    """
    cracker函数的主要作用是破解密钥
    :return: 返回密钥
    """
    with open("crypt.txt","r") as f:
        crypt = f.read()
    len_key, d = guess_len_key(crypt)
    key = ''
    print("\n-------------------------------------")
    print("|       经计算可知，密钥长度为%s         |" % len_key)
    print("-------------------------------------\n")
    for i in range(len_key):
        substring = d[i]
        print("当前字串为：",d[i])
        for n in range(26):
            dex = quasi_index(substring, n)     # quasi_index 拟重合指数
            print("假设子串移动{},拟重合指数为{:.4f}".format(s[n],dex))
            if dex >= 0.06 and dex <= 0.07:
                key += s[n]
                break
    print("******************************破解的最终密钥为%s*********************************" % key)
